Bug 1: Start hour upper bound changed from 23 to 26.
This bug is located in the isValid() function in Appt.java. Aaron changed the acceptable upper bound of startHour from 24 to 26. My original code from assignment 3, altered slightly to get more coverage caught this bug. I had set up a failing case for each of the conditions in isValid() and my failing case for startHour is to set it to a value that is just outside of the acceptable range (25), so the assertion associated with startHour’s validity failed, thus telling me where the bug is. 

Bug 2: Add amount 0. 
This bug is located in getApptRange in TimeTable.java. In this function, a GregorianCalendar variable called nextday, storing a clone of the first day (parameter) and used to accumulate the difference between the first day and the day of occurrence of the appointment. These are accumulated by using nextday’s .add() method, to which Aaron passes the day of the month (so far so good) and 0 for the amount, which is the source of the issue. This bug was discovered when I decided to dig into why my assignment 3 TimeTable test would always hang. (At first I just removed the TimeTableTest.java file so that I could focus elsewhere.) Narrowing the issue down to this bug in particular came down to using my intuition. The first reason I thought of for why the process was hanging is that it was stuck in some sort of weird infinite loop. I first checked the bounds of all for loops and increments used, but those checked out. Thus the issue was somewhere in the while loops. I recalled being very confused by part of getApptRange that involved the nested while loops in previous assignments and so I read up on the documentation of all of the functions that are used that I was not already familiar with. I needed only a cursory reading of GregorianCalendar.add(int, int) to understand that this function does not expect an amount (second argument) of 0. It says on Oracle’s documentation page (I paraphrase) that the difference of the value of the field (the first argument) after and before add is called is equal to the amount. Thus, since the while loop that this call to add is found in is meant to iterate over a range of days, the value of the field should increase by one with the function call, leaving a difference that is nonzero, for sure. Thus, I concluded that by passing 0 into the add function as the amount, Aaron is inviting irregular behavior out this function. In order to verify my hunch that this was the bug, I changed the value to 1 and ran the test. Sure enough, this time the test did not hang, but executed the rest of my tests. The results of these tests were useless because I did not finish the TimeTable section of assignment 3, but in verifying further I came across another bug. (See Bug 3.)

Bug 3:	In order to make sure that the above fix (changing the value passed as amount from 0 to 1) did, in fact, make the getApptRange function work correctly, I wrote another test (it is test02 in TimeTableTest.java). In summary, the test will generated a list of appts, then call getApptRange with this list and day boundaries which include all appt’s in appts, and comparing the appts that were returned in the CalDays list to the originals. When I ran this test, it still failed. So I went through the same process of checking what could be wrong that I did to find bug 2: I went straight to checking for loop bounds. Immediately I saw something unusual: iteration in the for loop that treverses the list of appts begins at 1 and goes until one less than the size of the appt list. This means that for any positive size of appts, the loop will iterate one time fewer than the total number of appt’s in appts. This is problematic because the loop will never evaluate the first element in the list. To test this hunch, I fixed both Bug #2 and this one and ran the code against my test02. This time, it passed. The conclusion, therefore, is that with the function otherwise performing properly, given the fixing of Bug #2, beginning iteration at 1 rather than 0 is the bug.

